#!/usr/bin/env python
"""sql_dump

Dump the DDL of the MySQL tables of the given environment in the sql/ directory
of Hotlanta.

Usage:
    sql_dump [options] <environment> [<databases>...]
    sql_dump -h | --help

Options:
    --check-tables  Check for extra or missing tables too
    --no-dump       Display the db differences instead of dumping DDL to file
    -v --verbose    Enable the debugging output.
    -h --help       Show this screen.

Supported environments:
   prclt.net
   chai.qaolate.com
   pekoe.qaolate.com
   devolate.com

"""
import logging
import os.path
from ConfigParser import SafeConfigParser
from subprocess import Popen
from docopt import docopt
import socket
from time import sleep
from socket import getfqdn
import sys
import os


# Hack to import some helpful lib without having to hack the PYTHONPATH
sys.path.append(os.path.join(os.path.dirname(__file__), '..', 'lib', 'ini_db'))
from ini_db import Database  # noqa


# All the supported environments
VALID_ENVS = frozenset(['prclt.net',
                        'chai.qaolate.com',
                        'pekoe.qaolate.com',
                        'devolate.com'])

# The list of environments that do not require any SSH tunneling
LOCAL_ENVS = frozenset(['devolate.com'])

# The bastion host used to tunnel to the database
GATEWAY_HOST = u'gateway.prclt.net'


class Tunnel(object):
    """Wraps a SSH tunnel"""

    def __init__(self, host, port):
        """
        Args:
            host (str)
            port (int)
        """
        assert isinstance(host, str)
        assert isinstance(port, int)

        self.host = host
        self.port = port

        logging.debug("Creating a tunnel to %s:%s...", self.host, self.port)
        ssh_l_option = '-L {}:{}:{}'.format(self.port, self.host, self.port)
        self.process = Popen(['ssh', '-N', ssh_l_option, GATEWAY_HOST])

    @property
    def ready(self):
        """
        Check if the tunnel is ready

        Returns:
            bool
        """
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        result = sock.connect_ex(('localhost', self.port))

        if result == 0:
            is_ready = True
        else:
            is_ready = False

        sock.close()

        return is_ready

    def __del__(self):
        logging.debug("Closing the tunnel to %s:%s...", self.host, self.port)
        self.process.kill()


def get_domain_name():
    """
    Returns the current domain name used.

    Returns:
        str
    """
    fqdn = getfqdn()

    # Live
    if fqdn.endswith('prclt.net'):
        domain_name = 'prclt.net'
    # Devolate
    elif fqdn.endswith('devolate.com'):
        domain_name = 'devolate.com'
    # QA Clusters
    elif fqdn.endswith('chai.qaolate.com'):
        domain_name = 'chai.qaolate.com'
    elif fqdn.endswith('pekoe.qaolate.com'):
        domain_name = 'pekoe.qaolate.com'

    # If none of the above it means we are running this locally
    # In that case, we give domain_name whatever value getfqdn() returns
    # and open a tunnel
    else:
        domain_name = fqdn

    return domain_name


def create_tunnel(env, db):
    """
    Creates an SSH tunnel if needed for communicating with a remote db.

    Args:
        env (str) The environment/cluster db that we are testing against master
        db (Database)

    Returns:
        tunnel (Tunnel)
    """
    assert isinstance(env, str)
    assert isinstance(db, Database)
    assert env in VALID_ENVS

    domain_name = get_domain_name()
    if domain_name != env:
        if env not in LOCAL_ENVS:
            tunnel = Tunnel(db.host, db.port)

            while not tunnel.ready:
                logging.debug("Waiting for the tunnel to be ready...")
                sleep(1)

            logging.debug("Tunnel ready!")
            db.host = '127.0.0.1'
        else:
            tunnel = None
    else:
        tunnel = None

    return tunnel


def path_to_db_ini(env):
    """
    Returns the path to the legitimate databases.ini file for the given env.

    Args:
        env (str)

    Returns:
        str
    """
    assert isinstance(env, str)
    assert env in VALID_ENVS

    bin_dir_path = os.path.dirname(os.path.realpath(__file__))
    parent_dir_path = os.path.dirname(bin_dir_path)
    path_to_db_ini = os.path.join(parent_dir_path, 'etc', env, 'databases.ini')

    return path_to_db_ini


def path_to_sql_dump(db_name):
    """
    Returns the path to the legitimate SQL file for the given database.

    Args:
        db_name (str)

    Returns:
        str
    """
    assert isinstance(db_name, str)

    bin_dir_path = os.path.dirname(os.path.realpath(__file__))
    parent_dir_path = os.path.dirname(bin_dir_path)
    path_to_sql = os.path.join(parent_dir_path, 'sql', db_name + '.sql')

    return path_to_sql


def check_env(env):
    """
    Check that the given environment is valid.
    Environment means anything required for a good run.
    If not, output an error message and exits.

    Args:
        env (str)
    """
    assert isinstance(env, str)

    # Check that the env specified is valid
    if env not in VALID_ENVS:
        list_of_envs = ', '.join(VALID_ENVS)
        exit('Not a valid environment.\n'
             'Valid envs: {}'
             .format(list_of_envs))

    # Check that we can find the database settings
    db_ini_path = path_to_db_ini(env)
    if not os.path.isfile(db_ini_path):
        exit('Unable to load {}'.format(db_ini_path))


def get_db_config(env):
    """
    Get the databases config for the given environment.

    Args:
        env (str)

    Returns:
        str
    """
    assert isinstance(env, str)
    assert env in VALID_ENVS

    ini_path = path_to_db_ini(env)
    db_conf = SafeConfigParser()
    db_conf.read(ini_path)

    return db_conf


def dump_db_ddl(db_conf, env, db_name):
    """
    Dump the DDLs of the given database

    Args:
        db_conf (SafeConfigParser)
        env (str)
        db_name (str)
    """
    assert isinstance(db_conf, SafeConfigParser)
    assert isinstance(db_name, str)
    assert env in VALID_ENVS

    if db_name not in db_conf.sections():
        print("Invalid database for {}: {}".format(env, db_name))
    else:
        db = Database(db_id=db_name,
                      host=db_conf.get(db_name, 'host'),
                      port=db_conf.getint(db_name, 'port'),
                      name=db_conf.get(db_name, 'name'),
                      user=db_conf.get(db_name, 'user'),
                      password=db_conf.get(db_name, 'password'),
                      tables=db_conf.get(db_name, 'tables').split(',\n'))

        # Let's output some concise info
        print("Dumping the DDL of {} from {}...".format(db.db_id, db.host))

        # Creates a tunnel if the database needs one
        tunnel = create_tunnel(env, db)

        # Dump the DDL
        ddl = db.show_create()

        # Destroys the tunnel if any
        if tunnel:
            del tunnel

        # Store the DDL in a file
        path = path_to_sql_dump(db.db_id)
        with open(path, 'w') as sql_file:
            sql_file.write(ddl)


def get_unsynced_dadabases(env):
    """
    Returns a set of databases with differences on a given environment.

    Args:
        env (str)

    Returns:
        set()
    """
    assert isinstance(env, str)
    assert env in VALID_ENVS

    diff_dbs = set()

    logging.debug("Getting the DB config for the env %s", env)
    db_conf = get_db_config(env)
    for section in db_conf.sections():
        db = Database(db_id=section,
                      host=db_conf.get(section, 'host'),
                      port=db_conf.getint(section, 'port'),
                      name=db_conf.get(section, 'name'),
                      user=db_conf.get(section, 'user'),
                      password=db_conf.get(section, 'password'),
                      tables=db_conf.get(section, 'tables').split(',\n'))

        # Creates a tunnel if the database needs one
        tunnel = create_tunnel(env, db)

        # Dump the DDL
        ddl = db.show_create()

        if tunnel:
            del tunnel

        path = path_to_sql_dump(db.db_id)
        with open(path, 'r') as sql_file:
            # Create sql_file and ddl variables to compare
            sql_file_compare = ''.join(sql_file.readlines())

        ddl_compare = ''.join(ddl.encode('ascii'))

        if ddl_compare != sql_file_compare:
            diff_dbs.add(db.name)

    return diff_dbs


def detect_missing_tables(env):
    """
    Compare the live databases with the databases declared in the ini files
    of the given environment and list the tables that exist live but are not
    declared in INI files.
    """
    db_conf = get_db_config(env)
    for section in db_conf.sections():
        db = Database(db_id=section,
                      host=db_conf.get(section, 'host'),
                      port=db_conf.getint(section, 'port'),
                      name=db_conf.get(section, 'name'),
                      user=db_conf.get(section, 'user'),
                      password=db_conf.get(section, 'password'),
                      tables=db_conf.get(section, 'tables').split(',\n'))

        all_tables_in_ini = db.get_tables_in_ini()

        # Creates a tunnel if the database needs one
        tunnel = create_tunnel(env, db)

        live_tables = db.get_live_tables()

        # Destroys the tunnel if any
        if tunnel:
            del tunnel

        all_tables_not_in_db = all_tables_in_ini - live_tables
        if all_tables_not_in_db:
            print 'Tables missing in the {} db:'.format(db.host)
            for table in all_tables_not_in_db:
                print ' - ' + table


def detect_extraneous_tables(env):
    """
    Compare the live databases with the databases declared in the ini files
    of the given environment and list the tables that are declared in the ini
    files but that do not exist live.
    """
    db_conf = get_db_config(env)
    for section in db_conf.sections():
        db = Database(db_id=section,
                      host=db_conf.get(section, 'host'),
                      port=db_conf.getint(section, 'port'),
                      name=db_conf.get(section, 'name'),
                      user=db_conf.get(section, 'user'),
                      password=db_conf.get(section, 'password'),
                      tables=db_conf.get(section, 'tables').split(',\n'))

        all_tables_in_ini = db.get_tables_in_ini()

        # Creates a tunnel if the database needs one
        tunnel = create_tunnel(env, db)

        live_tables = db.get_live_tables()

        # Destroys the tunnel if any
        if tunnel:
            del tunnel

        all_tables_not_in_ini = live_tables - all_tables_in_ini
        if all_tables_not_in_ini:
            print 'Tables not in live {} db:'.format(db.host)
            for table in all_tables_not_in_ini:
                print " - " + table


def main():

    # Parse the args
    args = docopt(__doc__)
    env = args['<environment>']
    dbs = args['<databases>']

    # If asked to be verbose, enable the debug logging
    if args['--verbose']:
        logging.basicConfig(level=logging.DEBUG)

    # Check the env arg given on the command line
    check_env(env)

    if args['--no-dump']:
        bad_dbs = get_unsynced_dadabases(env)
        if bad_dbs:
            print 'Some databases are not in sync:'
            for bad_db in bad_dbs:
                print " - {}".format(bad_db)
            print
            print 'Please run sql_dump to fix them.'

            return 1

    # Check if there are any missing tables between databases.ini
    # and the servers
    if args['--check-tables']:
        detect_missing_tables(env)
        detect_extraneous_tables(env)

    # Do the real dumping
    if not args['--no-dump']:
        logging.debug("Getting the DB config for the env %s", env)
        db_conf = get_db_config(env)

        if dbs:
            for db in dbs:
                dump_db_ddl(db_conf, env, db)
        else:
            for db in db_conf.sections():
                dump_db_ddl(db_conf, env, db)


if __name__ == '__main__':

    sys.exit(main())
